import { SurveyModel } from "../survey";
import { Base, EventBase } from "../base";
import { IShortcutText, ISurvey } from "../base-interfaces";
export declare abstract class DragDropCore<T> extends Base {
    private surveyValue?;
    private creator?;
    private longTap?;
    isBottom: boolean;
    onGhostPositionChanged: EventBase<{}>;
    protected ghostPositionChanged(): void;
    static PreventScrolling: boolean;
    onDragStart: EventBase<DragDropCore<T>>;
    onDragEnd: EventBase<DragDropCore<T>>;
    onBeforeDrop: EventBase<DragDropCore<T>, any>;
    onAfterDrop: EventBase<DragDropCore<T>, any>;
    draggedElement: any;
    protected abstract readonly draggedElementType: string;
    protected parentElement: T;
    dropTarget: any;
    protected readonly dropTargetDataAttributeName: string;
    protected readonly survey: SurveyModel;
    prevDropTarget: any;
    protected draggedElementShortcut: any;
    private scrollIntervalId;
    protected allowDropHere: boolean;
    constructor(surveyValue?: ISurvey, creator?: any, longTap?: boolean);
    startDrag(event: PointerEvent, draggedElement: any, parentElement?: any, draggedElementNode?: HTMLElement, preventSaveTargetNode?: boolean): void;
    private timeoutID;
    private startX;
    private startY;
    private currentX;
    private currentY;
    private savedTargetNode;
    private startLongTapProcessing;
    private stopLongTapIfMoveEnough;
    private readonly isMicroMovement: any;
    private stopLongTap;
    private doStartDrag;
    private onContextMenu;
    private dragOver;
    private drop;
    protected isDropTargetDoesntChanged(newIsBottom: boolean): boolean;
    protected onStartDrag(): void;
    protected getShortcutText(draggedElement: IShortcutText): string;
    protected createDraggedElementShortcut(text: string, draggedElementNode?: HTMLElement, event?: PointerEvent): HTMLElement;
    protected getDraggedElementClass(): string;
    protected doDragOver(dropTargetNode?: HTMLElement, event?: PointerEvent): void;
    protected afterDragOver(dropTargetNode?: HTMLElement, event?: PointerEvent): void;
    getGhostPosition(item: any): string;
    protected abstract isDropTargetValid(dropTarget: any, dropTargetNode?: HTMLElement): boolean;
    private handlePointerCancel;
    protected handleEscapeButton: (event: KeyboardEvent) => void;
    private moveShortcutElement;
    private getShortcutBottomCoordinate;
    private getShortcutRightCoordinate;
    private doScroll;
    protected banDropHere: () => void;
    protected doBanDropHere: () => void;
    protected getDataAttributeValueByNode(node: HTMLElement): string;
    protected getDropTargetByNode(dropTargetNode: HTMLElement, event: PointerEvent): any;
    private capitalizeFirstLetter;
    protected abstract getDropTargetByDataAttributeValue(dataAttributeValue: string, dropTargetNode?: HTMLElement, event?: PointerEvent): any;
    protected calculateVerticalMiddleOfHTMLElement(HTMLElement: HTMLElement): number;
    protected calculateHorizontalMiddleOfHTMLElement(HTMLElement: HTMLElement): number;
    protected abstract calculateIsBottom(clientY: number, dropTargetNode?: HTMLElement): boolean;
    private findDropTargetNodeFromPoint;
    protected findDropTargetNodeByDragOverNode(dragOverNode: HTMLElement): HTMLElement;
    protected abstract doDrop(): any;
    protected clear: () => void;
    protected doClear(): void;
}
