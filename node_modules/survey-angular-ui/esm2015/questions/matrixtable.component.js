import { Component, Input } from "@angular/core";
import { BaseAngular } from "../base-angular";
import * as i0 from "@angular/core";
import * as i1 from "../survey-string.component";
import * as i2 from "./matrixrequiredheader.component";
import * as i3 from "./matrix-row.component";
import * as i4 from "./matrixcell.component";
import * as i5 from "@angular/common";
import * as i6 from "../utils/dynamic.directive";
export class MatrixTableComponent extends BaseAngular {
    getModel() {
        return this.table;
    }
    trackCellBy(_, cell) {
        return cell.id;
    }
    trackRowBy(index, row) {
        return row.id;
    }
}
MatrixTableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MatrixTableComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
MatrixTableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: MatrixTableComponent, selector: "sv-ng-matrix-table", inputs: { question: "question", table: "table" }, usesInheritance: true, ngImport: i0, template: "<div [style]=\"{ overflowX: question.showHorizontalScroll ? 'scroll' : '' }\" #contentElement [class]=\"question.cssClasses.tableWrapper\">\n  <table [class]=\"question.getTableCss()\">\n    <thead *ngIf=\"table.showHeader\">\n      <tr>\n        <ng-container\n          *ngFor=\"let cell of table.headerRow.cells; trackBy: trackCellBy\"\n        >\n              <th *ngIf=\"cell.hasTitle\" [class]=\"cell.className\" [style]=\"{ minWidth: cell.minWidth, width: cell.width }\">\n                <ng-template [component]=\"{ name: question.getColumnHeaderWrapperComponentName($any(cell)), data: { componentData: question.getColumnHeaderWrapperComponentData($any(cell)) } }\">\n                  <sv-ng-string [model]=\"cell.locTitle\"></sv-ng-string>\n                  <sv-ng-matrixheaderrequired *ngIf=\"!!cell.column\" [column]=\"cell.column\" [question]=\"question\">\n                  </sv-ng-matrixheaderrequired>\n                </ng-template>\n              </th>\n              \n              <td *ngIf=\"!cell.hasTitle\" [class]=\"cell.className\" [style]=\"{ minWidth: cell.minWidth, width: cell.width }\"></td>\n        </ng-container>\n      </tr>\n    </thead>\n    <tbody>\n      <ng-container *ngFor=\"let row of table.rows; trackBy: trackRowBy\">\n        <sv-ng-matrix-row [model]=\"row\" [question]=\"question\"></sv-ng-matrix-row>\n      </ng-container>\n    </tbody>\n    <tfoot *ngIf=\"table.showFooter\">\n      <tr>\n        <sv-ng-matrix-cell [cell]=\"cell\" [question]=\"question\" *ngFor=\"let cell of table.footerRow.cells; trackBy: trackCellBy\">\n        </sv-ng-matrix-cell>\n      </tr>\n    </tfoot>\n  </table>\n</div>", components: [{ type: i1.SurveyStringComponent, selector: "sv-ng-string, '[sv-ng-string]'", inputs: ["model"] }, { type: i2.MatrixRequiredHeader, selector: "sv-ng-matrixheaderrequired", inputs: ["column", "question"] }, { type: i3.MatrixRowComponent, selector: "sv-ng-matrix-row", inputs: ["model", "question"] }, { type: i4.MatrixCellComponent, selector: "sv-ng-matrix-cell", inputs: ["question", "cell"] }], directives: [{ type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i6.DynamicComponentDirective, selector: "[component]", inputs: ["component"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: MatrixTableComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "sv-ng-matrix-table",
                    templateUrl: "./matrixtable.component.html"
                }]
        }], propDecorators: { question: [{
                type: Input
            }], table: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0cml4dGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3F1ZXN0aW9ucy9tYXRyaXh0YWJsZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi9zcmMvcXVlc3Rpb25zL21hdHJpeHRhYmxlLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7Ozs7Ozs7QUFPOUMsTUFBTSxPQUFPLG9CQUFxQixTQUFRLFdBQWdEO0lBRzlFLFFBQVE7UUFDaEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFDTSxXQUFXLENBQUMsQ0FBUyxFQUFFLElBQVM7UUFDckMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFDTSxVQUFVLENBQUMsS0FBYSxFQUFFLEdBQVE7UUFDdkMsT0FBTyxHQUFHLENBQUMsRUFBRSxDQUFDO0lBQ2hCLENBQUM7O2tIQVhVLG9CQUFvQjtzR0FBcEIsb0JBQW9CLG1JQ1JqQywwbkRBK0JNOzRGRHZCTyxvQkFBb0I7a0JBSmhDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLG9CQUFvQjtvQkFDOUIsV0FBVyxFQUFFLDhCQUE4QjtpQkFDNUM7OEJBRVUsUUFBUTtzQkFBaEIsS0FBSztnQkFDRyxLQUFLO3NCQUFiLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IEJhc2VBbmd1bGFyIH0gZnJvbSBcIi4uL2Jhc2UtYW5ndWxhclwiO1xuaW1wb3J0IHsgUXVlc3Rpb25NYXRyaXhEcm9wZG93bk1vZGVsQmFzZSwgUXVlc3Rpb25NYXRyaXhEcm9wZG93blJlbmRlcmVkVGFibGUgfSBmcm9tIFwic3VydmV5LWNvcmVcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInN2LW5nLW1hdHJpeC10YWJsZVwiLFxuICB0ZW1wbGF0ZVVybDogXCIuL21hdHJpeHRhYmxlLmNvbXBvbmVudC5odG1sXCJcbn0pXG5leHBvcnQgY2xhc3MgTWF0cml4VGFibGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQW5ndWxhcjxRdWVzdGlvbk1hdHJpeERyb3Bkb3duUmVuZGVyZWRUYWJsZT4ge1xuICBASW5wdXQoKSBxdWVzdGlvbiE6IFF1ZXN0aW9uTWF0cml4RHJvcGRvd25Nb2RlbEJhc2U7XG4gIEBJbnB1dCgpIHRhYmxlITogUXVlc3Rpb25NYXRyaXhEcm9wZG93blJlbmRlcmVkVGFibGU7XG4gIHByb3RlY3RlZCBnZXRNb2RlbCgpOiBRdWVzdGlvbk1hdHJpeERyb3Bkb3duUmVuZGVyZWRUYWJsZSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGU7XG4gIH1cbiAgcHVibGljIHRyYWNrQ2VsbEJ5KF86IG51bWJlciwgY2VsbDogYW55KTogc3RyaW5nIHtcbiAgICByZXR1cm4gY2VsbC5pZDtcbiAgfVxuICBwdWJsaWMgdHJhY2tSb3dCeShpbmRleDogbnVtYmVyLCByb3c6IGFueSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHJvdy5pZDtcbiAgfVxufVxuIiwiPGRpdiBbc3R5bGVdPVwieyBvdmVyZmxvd1g6IHF1ZXN0aW9uLnNob3dIb3Jpem9udGFsU2Nyb2xsID8gJ3Njcm9sbCcgOiAnJyB9XCIgI2NvbnRlbnRFbGVtZW50IFtjbGFzc109XCJxdWVzdGlvbi5jc3NDbGFzc2VzLnRhYmxlV3JhcHBlclwiPlxuICA8dGFibGUgW2NsYXNzXT1cInF1ZXN0aW9uLmdldFRhYmxlQ3NzKClcIj5cbiAgICA8dGhlYWQgKm5nSWY9XCJ0YWJsZS5zaG93SGVhZGVyXCI+XG4gICAgICA8dHI+XG4gICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgY2VsbCBvZiB0YWJsZS5oZWFkZXJSb3cuY2VsbHM7IHRyYWNrQnk6IHRyYWNrQ2VsbEJ5XCJcbiAgICAgICAgPlxuICAgICAgICAgICAgICA8dGggKm5nSWY9XCJjZWxsLmhhc1RpdGxlXCIgW2NsYXNzXT1cImNlbGwuY2xhc3NOYW1lXCIgW3N0eWxlXT1cInsgbWluV2lkdGg6IGNlbGwubWluV2lkdGgsIHdpZHRoOiBjZWxsLndpZHRoIH1cIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW2NvbXBvbmVudF09XCJ7IG5hbWU6IHF1ZXN0aW9uLmdldENvbHVtbkhlYWRlcldyYXBwZXJDb21wb25lbnROYW1lKCRhbnkoY2VsbCkpLCBkYXRhOiB7IGNvbXBvbmVudERhdGE6IHF1ZXN0aW9uLmdldENvbHVtbkhlYWRlcldyYXBwZXJDb21wb25lbnREYXRhKCRhbnkoY2VsbCkpIH0gfVwiPlxuICAgICAgICAgICAgICAgICAgPHN2LW5nLXN0cmluZyBbbW9kZWxdPVwiY2VsbC5sb2NUaXRsZVwiPjwvc3Ytbmctc3RyaW5nPlxuICAgICAgICAgICAgICAgICAgPHN2LW5nLW1hdHJpeGhlYWRlcnJlcXVpcmVkICpuZ0lmPVwiISFjZWxsLmNvbHVtblwiIFtjb2x1bW5dPVwiY2VsbC5jb2x1bW5cIiBbcXVlc3Rpb25dPVwicXVlc3Rpb25cIj5cbiAgICAgICAgICAgICAgICAgIDwvc3YtbmctbWF0cml4aGVhZGVycmVxdWlyZWQ+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIDx0ZCAqbmdJZj1cIiFjZWxsLmhhc1RpdGxlXCIgW2NsYXNzXT1cImNlbGwuY2xhc3NOYW1lXCIgW3N0eWxlXT1cInsgbWluV2lkdGg6IGNlbGwubWluV2lkdGgsIHdpZHRoOiBjZWxsLndpZHRoIH1cIj48L3RkPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgIDwvdHI+XG4gICAgPC90aGVhZD5cbiAgICA8dGJvZHk+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCByb3cgb2YgdGFibGUucm93czsgdHJhY2tCeTogdHJhY2tSb3dCeVwiPlxuICAgICAgICA8c3YtbmctbWF0cml4LXJvdyBbbW9kZWxdPVwicm93XCIgW3F1ZXN0aW9uXT1cInF1ZXN0aW9uXCI+PC9zdi1uZy1tYXRyaXgtcm93PlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC90Ym9keT5cbiAgICA8dGZvb3QgKm5nSWY9XCJ0YWJsZS5zaG93Rm9vdGVyXCI+XG4gICAgICA8dHI+XG4gICAgICAgIDxzdi1uZy1tYXRyaXgtY2VsbCBbY2VsbF09XCJjZWxsXCIgW3F1ZXN0aW9uXT1cInF1ZXN0aW9uXCIgKm5nRm9yPVwibGV0IGNlbGwgb2YgdGFibGUuZm9vdGVyUm93LmNlbGxzOyB0cmFja0J5OiB0cmFja0NlbGxCeVwiPlxuICAgICAgICA8L3N2LW5nLW1hdHJpeC1jZWxsPlxuICAgICAgPC90cj5cbiAgICA8L3Rmb290PlxuICA8L3RhYmxlPlxuPC9kaXY+Il19