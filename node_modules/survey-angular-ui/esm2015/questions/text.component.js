import { Component } from "@angular/core";
import { QuestionAngular } from "../question";
import { AngularComponentFactory } from "../component-factory";
import * as i0 from "@angular/core";
import * as i1 from "../components/character-counter/character-counter.component";
import * as i2 from "@angular/common";
import * as i3 from "@angular/forms";
export class TextQuestionComponent extends QuestionAngular {
    get value() {
        var _a;
        return (_a = this.model.value) !== null && _a !== void 0 ? _a : "";
    }
}
TextQuestionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextQuestionComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
TextQuestionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TextQuestionComponent, selector: "sv-ng-text-question", usesInheritance: true, ngImport: i0, template: "  <ng-container [ngTemplateOutlet]=\"input\" *ngIf=\"!model.dataListId && !model.isReadOnlyRenderDiv()\"></ng-container>\n  <div *ngIf=\"model.dataListId && !model.isReadOnlyRenderDiv()\">\n    <ng-container [ngTemplateOutlet]=\"input\"></ng-container>\n    <datalist [id]=\"model.dataListId\">\n      <option *ngFor=\"let dataListItem of model.dataList\" [value]=\"dataListItem\"></option>\n    </datalist>\n  </div>\n  <div *ngIf=\"model.isReadOnlyRenderDiv()\" #contentElement>{{ model.value }}</div>\n  <ng-template #input>\n    <input [style]=\"model.inputStyle\" [class]=\"model.getControlClass()\" [attr.list]=\"model.dataListId\"\n    (change)=\"model.onChange($event)\" [value]=\"value\" [disabled]=\"model.isInputReadOnly\" name=\"user\" [type]=\"model.inputType\" [id]=\"model.inputId\" [attr.placeholder]=\"model.renderedPlaceholder || ''\"\n    (keyup)=\"model.onKeyUp($event)\" (keydown)=\"model.onKeyDown($event)\" (blur)=\"model.onBlur($event)\" (focus)=\"model.onFocus($event)\" (compositionupdate)=\"model.onCompositionUpdate($event)\" \n    [attr.size] = \"model.renderedInputSize\" [attr.maxlength]= \"model.getMaxLength()\" [attr.min]=\"model.renderedMin\"\n    [attr.max]=\"model.renderedMax\" [attr.step]=\"model.renderedStep\" [attr.max]=\"model.renderedMax\" [attr.aria-required]=\"model.ariaRequired\"\n    [attr.aria-label]=\"model.ariaLabel\" [attr.aria-invalid]=\"model.ariaInvalid\" [attr.aria-describedby]=\"model.ariaDescribedBy\" [attr.autocomplete]=\"model.autocomplete\" #contentElement/>\n    <sv-ng-character-counter *ngIf=\"model.getMaxLength()\" \n    [counter]=\"model.characterCounter\"\n    [remainingCharacterCounter]=\"model.cssClasses.remainingCharacterCounter\">\n  </sv-ng-character-counter>\n  </ng-template>", styles: [""], components: [{ type: i1.CharacterCounterComponent, selector: "sv-ng-character-counter", inputs: ["counter", "remainingCharacterCounter"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { type: i3.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextQuestionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "sv-ng-text-question",
                    templateUrl: "./text.component.html",
                    styleUrls: ["./text.component.scss"]
                }]
        }] });
AngularComponentFactory.Instance.registerComponent("text-question", TextQuestionComponent);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcXVlc3Rpb25zL3RleHQuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vc3JjL3F1ZXN0aW9ucy90ZXh0LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUU5QyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQzs7Ozs7QUFPL0QsTUFBTSxPQUFPLHFCQUFzQixTQUFRLGVBQWtDO0lBQzNFLElBQUksS0FBSzs7UUFDUCxPQUFPLE1BQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLG1DQUFJLEVBQUUsQ0FBQztJQUNoQyxDQUFDOzttSEFIVSxxQkFBcUI7dUdBQXJCLHFCQUFxQixrRkNWbEMsOHREQW1CZ0I7NEZEVEgscUJBQXFCO2tCQUxqQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxxQkFBcUI7b0JBQy9CLFdBQVcsRUFBRSx1QkFBdUI7b0JBQ3BDLFNBQVMsRUFBRSxDQUFDLHVCQUF1QixDQUFDO2lCQUNyQzs7QUFPRCx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsZUFBZSxFQUFFLHFCQUFxQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgUXVlc3Rpb25Bbmd1bGFyIH0gZnJvbSBcIi4uL3F1ZXN0aW9uXCI7XG5pbXBvcnQgeyBRdWVzdGlvblRleHRNb2RlbCB9IGZyb20gXCJzdXJ2ZXktY29yZVwiO1xuaW1wb3J0IHsgQW5ndWxhckNvbXBvbmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vY29tcG9uZW50LWZhY3RvcnlcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInN2LW5nLXRleHQtcXVlc3Rpb25cIixcbiAgdGVtcGxhdGVVcmw6IFwiLi90ZXh0LmNvbXBvbmVudC5odG1sXCIsXG4gIHN0eWxlVXJsczogW1wiLi90ZXh0LmNvbXBvbmVudC5zY3NzXCJdXG59KVxuZXhwb3J0IGNsYXNzIFRleHRRdWVzdGlvbkNvbXBvbmVudCBleHRlbmRzIFF1ZXN0aW9uQW5ndWxhcjxRdWVzdGlvblRleHRNb2RlbD4ge1xuICBnZXQgdmFsdWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC52YWx1ZSA/PyBcIlwiO1xuICB9XG59XG5cbkFuZ3VsYXJDb21wb25lbnRGYWN0b3J5Lkluc3RhbmNlLnJlZ2lzdGVyQ29tcG9uZW50KFwidGV4dC1xdWVzdGlvblwiLCBUZXh0UXVlc3Rpb25Db21wb25lbnQpOyIsIiAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJpbnB1dFwiICpuZ0lmPVwiIW1vZGVsLmRhdGFMaXN0SWQgJiYgIW1vZGVsLmlzUmVhZE9ubHlSZW5kZXJEaXYoKVwiPjwvbmctY29udGFpbmVyPlxuICA8ZGl2ICpuZ0lmPVwibW9kZWwuZGF0YUxpc3RJZCAmJiAhbW9kZWwuaXNSZWFkT25seVJlbmRlckRpdigpXCI+XG4gICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJpbnB1dFwiPjwvbmctY29udGFpbmVyPlxuICAgIDxkYXRhbGlzdCBbaWRdPVwibW9kZWwuZGF0YUxpc3RJZFwiPlxuICAgICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgZGF0YUxpc3RJdGVtIG9mIG1vZGVsLmRhdGFMaXN0XCIgW3ZhbHVlXT1cImRhdGFMaXN0SXRlbVwiPjwvb3B0aW9uPlxuICAgIDwvZGF0YWxpc3Q+XG4gIDwvZGl2PlxuICA8ZGl2ICpuZ0lmPVwibW9kZWwuaXNSZWFkT25seVJlbmRlckRpdigpXCIgI2NvbnRlbnRFbGVtZW50Pnt7IG1vZGVsLnZhbHVlIH19PC9kaXY+XG4gIDxuZy10ZW1wbGF0ZSAjaW5wdXQ+XG4gICAgPGlucHV0IFtzdHlsZV09XCJtb2RlbC5pbnB1dFN0eWxlXCIgW2NsYXNzXT1cIm1vZGVsLmdldENvbnRyb2xDbGFzcygpXCIgW2F0dHIubGlzdF09XCJtb2RlbC5kYXRhTGlzdElkXCJcbiAgICAoY2hhbmdlKT1cIm1vZGVsLm9uQ2hhbmdlKCRldmVudClcIiBbdmFsdWVdPVwidmFsdWVcIiBbZGlzYWJsZWRdPVwibW9kZWwuaXNJbnB1dFJlYWRPbmx5XCIgbmFtZT1cInVzZXJcIiBbdHlwZV09XCJtb2RlbC5pbnB1dFR5cGVcIiBbaWRdPVwibW9kZWwuaW5wdXRJZFwiIFthdHRyLnBsYWNlaG9sZGVyXT1cIm1vZGVsLnJlbmRlcmVkUGxhY2Vob2xkZXIgfHwgJydcIlxuICAgIChrZXl1cCk9XCJtb2RlbC5vbktleVVwKCRldmVudClcIiAoa2V5ZG93bik9XCJtb2RlbC5vbktleURvd24oJGV2ZW50KVwiIChibHVyKT1cIm1vZGVsLm9uQmx1cigkZXZlbnQpXCIgKGZvY3VzKT1cIm1vZGVsLm9uRm9jdXMoJGV2ZW50KVwiIChjb21wb3NpdGlvbnVwZGF0ZSk9XCJtb2RlbC5vbkNvbXBvc2l0aW9uVXBkYXRlKCRldmVudClcIiBcbiAgICBbYXR0ci5zaXplXSA9IFwibW9kZWwucmVuZGVyZWRJbnB1dFNpemVcIiBbYXR0ci5tYXhsZW5ndGhdPSBcIm1vZGVsLmdldE1heExlbmd0aCgpXCIgW2F0dHIubWluXT1cIm1vZGVsLnJlbmRlcmVkTWluXCJcbiAgICBbYXR0ci5tYXhdPVwibW9kZWwucmVuZGVyZWRNYXhcIiBbYXR0ci5zdGVwXT1cIm1vZGVsLnJlbmRlcmVkU3RlcFwiIFthdHRyLm1heF09XCJtb2RlbC5yZW5kZXJlZE1heFwiIFthdHRyLmFyaWEtcmVxdWlyZWRdPVwibW9kZWwuYXJpYVJlcXVpcmVkXCJcbiAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIm1vZGVsLmFyaWFMYWJlbFwiIFthdHRyLmFyaWEtaW52YWxpZF09XCJtb2RlbC5hcmlhSW52YWxpZFwiIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwibW9kZWwuYXJpYURlc2NyaWJlZEJ5XCIgW2F0dHIuYXV0b2NvbXBsZXRlXT1cIm1vZGVsLmF1dG9jb21wbGV0ZVwiICNjb250ZW50RWxlbWVudC8+XG4gICAgPHN2LW5nLWNoYXJhY3Rlci1jb3VudGVyICpuZ0lmPVwibW9kZWwuZ2V0TWF4TGVuZ3RoKClcIiBcbiAgICBbY291bnRlcl09XCJtb2RlbC5jaGFyYWN0ZXJDb3VudGVyXCJcbiAgICBbcmVtYWluaW5nQ2hhcmFjdGVyQ291bnRlcl09XCJtb2RlbC5jc3NDbGFzc2VzLnJlbWFpbmluZ0NoYXJhY3RlckNvdW50ZXJcIj5cbiAgPC9zdi1uZy1jaGFyYWN0ZXItY291bnRlcj5cbiAgPC9uZy10ZW1wbGF0ZT4iXX0=