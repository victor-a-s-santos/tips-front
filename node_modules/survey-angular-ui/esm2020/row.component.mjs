import { Component, ElementRef, Input, ViewChild } from "@angular/core";
import { BaseAngular } from "./base-angular";
import * as i0 from "@angular/core";
import * as i1 from "./element.component";
import * as i2 from "@angular/common";
import * as i3 from "./utils/dynamic.directive";
export class RowComponent extends BaseAngular {
    constructor(cdr, vcr, ngZone) {
        super(cdr, vcr);
        this.ngZone = ngZone;
    }
    getModel() {
        return this.row;
    }
    trackElementBy(index, element) {
        return element.name + index;
    }
    ngAfterViewInit() {
        const el = this.container?.nativeElement;
        if (!!el && !this.row.isNeedRender) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.row.startLazyRendering(el);
                }, 10);
            });
        }
    }
    onModelChanged() {
        super.onModelChanged();
        if (!this.previousModel) {
            return;
        }
        else {
            this.row.isNeedRender = this.previousModel.isNeedRender;
            this.stopLazyRendering();
        }
    }
    stopLazyRendering() {
        this.row.stopLazyRendering();
        this.row.isNeedRender = !this.row.isLazyRendering();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.stopLazyRendering();
    }
}
RowComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: i0, type: RowComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ViewContainerRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
RowComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.0.3", type: RowComponent, selector: "sv-ng-row", inputs: { row: "row" }, viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: "<ng-template #template>\n  <div [class]=\"row.getRowCss()\" *ngIf=\"row.visible\" #container>\n    <ng-container *ngFor=\"let element of row.visibleElements; trackBy: trackElementBy\">\n      <sv-ng-element [model]=\"$any(element)\" *ngIf=\"row.isNeedRender\"></sv-ng-element>\n      <ng-template *ngIf=\"!row.isNeedRender && element.skeletonComponentName\" [component]=\"{ name: element.skeletonComponentName, data: { element: element } }\"></ng-template>\n    </ng-container>\n  </div>\n</ng-template>", styles: [":host{display:none}\n"], components: [{ type: i1.ElementComponent, selector: "sv-ng-element", inputs: ["model"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.DynamicComponentDirective, selector: "[component]", inputs: ["component"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: i0, type: RowComponent, decorators: [{
            type: Component,
            args: [{ selector: "sv-ng-row", template: "<ng-template #template>\n  <div [class]=\"row.getRowCss()\" *ngIf=\"row.visible\" #container>\n    <ng-container *ngFor=\"let element of row.visibleElements; trackBy: trackElementBy\">\n      <sv-ng-element [model]=\"$any(element)\" *ngIf=\"row.isNeedRender\"></sv-ng-element>\n      <ng-template *ngIf=\"!row.isNeedRender && element.skeletonComponentName\" [component]=\"{ name: element.skeletonComponentName, data: { element: element } }\"></ng-template>\n    </ng-container>\n  </div>\n</ng-template>", styles: [":host{display:none}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ViewContainerRef }, { type: i0.NgZone }]; }, propDecorators: { row: [{
                type: Input
            }], container: [{
                type: ViewChild,
                args: ["container", { read: ElementRef }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm93LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yb3cuY29tcG9uZW50LnRzIiwiLi4vLi4vc3JjL3Jvdy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQW9DLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFVLFNBQVMsRUFBb0IsTUFBTSxlQUFlLENBQUM7QUFFcEksT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7OztBQU03QyxNQUFNLE9BQU8sWUFBYSxTQUFRLFdBQTZCO0lBRzdELFlBQVksR0FBc0IsRUFBRSxHQUFxQixFQUFVLE1BQWM7UUFDL0UsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQURpRCxXQUFNLEdBQU4sTUFBTSxDQUFRO0lBRWpGLENBQUM7SUFFUyxRQUFRO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUNsQixDQUFDO0lBQ0QsY0FBYyxDQUFFLEtBQWEsRUFBRSxPQUFpQjtRQUM5QyxPQUFPLE9BQU8sQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO0lBQzlCLENBQUM7SUFDTSxlQUFlO1FBQ3BCLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFO1lBQ2xDLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFO2dCQUNqQyxVQUFVLENBQUMsR0FBRyxFQUFFO29CQUNkLElBQUksQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ2xDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNULENBQUMsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDO0lBQ2tCLGNBQWM7UUFDL0IsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3ZCLElBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3RCLE9BQU87U0FDUjthQUFNO1lBQ0wsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUM7WUFDeEQsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7U0FDMUI7SUFDSCxDQUFDO0lBQ08saUJBQWlCO1FBQ3ZCLElBQUksQ0FBQyxHQUFHLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUM3QixJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDdEQsQ0FBQztJQUNlLFdBQVc7UUFDekIsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQzNCLENBQUM7O3lHQXZDVSxZQUFZOzZGQUFaLFlBQVksNEpBRVMsVUFBVSxvRENWNUMseWZBT2M7MkZEQ0QsWUFBWTtrQkFMeEIsU0FBUzsrQkFDRSxXQUFXOzRKQUtaLEdBQUc7c0JBQVgsS0FBSztnQkFDd0MsU0FBUztzQkFBdEQsU0FBUzt1QkFBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE5nWm9uZSwgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IElFbGVtZW50LCBRdWVzdGlvblJvd01vZGVsIH0gZnJvbSBcInN1cnZleS1jb3JlXCI7XG5pbXBvcnQgeyBCYXNlQW5ndWxhciB9IGZyb20gXCIuL2Jhc2UtYW5ndWxhclwiO1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInN2LW5nLXJvd1wiLFxuICB0ZW1wbGF0ZVVybDogXCIuL3Jvdy5jb21wb25lbnQuaHRtbFwiLFxuICBzdHlsZVVybHM6IFtcIi4vaGlkZS1ob3N0LnNjc3NcIl1cbn0pXG5leHBvcnQgY2xhc3MgUm93Q29tcG9uZW50IGV4dGVuZHMgQmFzZUFuZ3VsYXI8UXVlc3Rpb25Sb3dNb2RlbD4gaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgQElucHV0KCkgcm93ITogUXVlc3Rpb25Sb3dNb2RlbDtcbiAgQFZpZXdDaGlsZChcImNvbnRhaW5lclwiLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSkgY29udGFpbmVyPzogRWxlbWVudFJlZjxIVE1MRGl2RWxlbWVudD47XG4gIGNvbnN0cnVjdG9yKGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHZjcjogVmlld0NvbnRhaW5lclJlZiwgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge1xuICAgIHN1cGVyKGNkciwgdmNyKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRNb2RlbCgpOiBRdWVzdGlvblJvd01vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5yb3c7XG4gIH1cbiAgdHJhY2tFbGVtZW50QnkgKGluZGV4OiBudW1iZXIsIGVsZW1lbnQ6IElFbGVtZW50KTogc3RyaW5nIHtcbiAgICByZXR1cm4gZWxlbWVudC5uYW1lICsgaW5kZXg7XG4gIH1cbiAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuY29udGFpbmVyPy5uYXRpdmVFbGVtZW50O1xuICAgIGlmICghIWVsICYmICF0aGlzLnJvdy5pc05lZWRSZW5kZXIpIHtcbiAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yb3cuc3RhcnRMYXp5UmVuZGVyaW5nKGVsKTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHByb3RlY3RlZCBvdmVycmlkZSBvbk1vZGVsQ2hhbmdlZCgpOiB2b2lkIHtcbiAgICBzdXBlci5vbk1vZGVsQ2hhbmdlZCgpO1xuICAgIGlmKCF0aGlzLnByZXZpb3VzTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb3cuaXNOZWVkUmVuZGVyID0gdGhpcy5wcmV2aW91c01vZGVsLmlzTmVlZFJlbmRlcjtcbiAgICAgIHRoaXMuc3RvcExhenlSZW5kZXJpbmcoKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBzdG9wTGF6eVJlbmRlcmluZygpIHtcbiAgICB0aGlzLnJvdy5zdG9wTGF6eVJlbmRlcmluZygpO1xuICAgIHRoaXMucm93LmlzTmVlZFJlbmRlciA9ICF0aGlzLnJvdy5pc0xhenlSZW5kZXJpbmcoKTtcbiAgfVxuICBwdWJsaWMgb3ZlcnJpZGUgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcbiAgICB0aGlzLnN0b3BMYXp5UmVuZGVyaW5nKCk7XG4gIH1cbn0iLCI8bmctdGVtcGxhdGUgI3RlbXBsYXRlPlxuICA8ZGl2IFtjbGFzc109XCJyb3cuZ2V0Um93Q3NzKClcIiAqbmdJZj1cInJvdy52aXNpYmxlXCIgI2NvbnRhaW5lcj5cbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBlbGVtZW50IG9mIHJvdy52aXNpYmxlRWxlbWVudHM7IHRyYWNrQnk6IHRyYWNrRWxlbWVudEJ5XCI+XG4gICAgICA8c3YtbmctZWxlbWVudCBbbW9kZWxdPVwiJGFueShlbGVtZW50KVwiICpuZ0lmPVwicm93LmlzTmVlZFJlbmRlclwiPjwvc3YtbmctZWxlbWVudD5cbiAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cIiFyb3cuaXNOZWVkUmVuZGVyICYmIGVsZW1lbnQuc2tlbGV0b25Db21wb25lbnROYW1lXCIgW2NvbXBvbmVudF09XCJ7IG5hbWU6IGVsZW1lbnQuc2tlbGV0b25Db21wb25lbnROYW1lLCBkYXRhOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSB9XCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgPC9kaXY+XG48L25nLXRlbXBsYXRlPiJdfQ==